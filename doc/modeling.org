* Modeling the Corporation

** Prerequisites
To understand this document you should be familiar with object-oriented programming and domain modeling.

See:
- http://martinfowler.com/eaaCatalog/domainModel.html
- http://www.martinfowler.com/bliki/AnemicDomainModel.html
** Misc Thoughts
In the financial services industry, UML and XML models for financial transactions exist: ISO 20022 is the basis for SWIFT.

Maybe we can import some of those ideas. A startup investment is, after all, just a special case of a financial transaction.

Corporations are relatively lightweight structures, especially at the startup stage. Even public corporations aren't terribly complex: they have a lot of shareholders, a few directors, and a bunch of bank accounts.

Astonishingly, we have not been able to find a data model schema for a corporation. So here's one.
** Entities
*** Primary Entity: Company

The Models given in this document claim to work for two kinds of primary entities. A Company is assumed to be one of the following:

**** Private Limited Companies                                              :SG:SG_CA50_20160103:

The Resolutions Model claims correctness for Singapore Private Limited Companies.

**** Exempt Private Limited Companies                                       :SG:SG_CA50_20160103:

For the purpose of the Resolutions Model, all facts true of Private Limited Companies are also true of Exempt Private Limited Companies.

*** Secondary Entities                                                                   :general:

Along the way, the following secondary entities will turn up:

**** Natural Person                                                                     :general:

Usually a human being. May be resident in any jurisdiction.

May be the estate, personal representative, attorney, etc, of a human being.

**** Organization                                                                       :general:

Synonymous with a corporate person -- anything that is not a natural person. For example, an investment holding company may be a corporate shareholder.

*** Roles

The following roles exist with-respect-to the Company.

**** General Role Attributes
a role relationship starts and stops in time. So we need [[https://en.wikipedia.org/wiki/Bitemporal_data][bitemporality]].

**** Director Role                                                                      :general:

**** Shareholder Role                                                                   :general:

May be of a specific class of shares.

**** Bondholder Role                                                                    :general:

Of a specific security.

**** Warrantholder Role                                                                 :general:

Of a specific security.

**** Investor Role                                                                      :general:

**** Member Role                                                            :SG:SG_CA50_20160103:

Often synonymous with shareholder, but specifically defined as a person entitled to receive notices of meetings.

Not tagged as global because the notion of a member may not be common outside Singapore jurisdiction.

*** Entities Out of Scope                                                                :general:

The resolution model does not claim to cover:

**** Companies Limited by Guarantee
**** Trusts
**** Public Companies

* Modeling the Drafting -- Semantics
Within a contract, we deal with terms and content. This model cares about the conceptual/abstract representation, also known as the formal representation. It also cares about the physical text in a natural language. The physical text may include formatting instructions.

** Background Reading
To understand this section, you should:
- be reading Ken Adams, A Manual of Style for Contract Drafting
- understand what a context-free grammar is, and be familiar with Backus-Naur Form
- read https://drive.google.com/open?id=0BxOaYa8pqqSwTC04OTF5b1hYams Some computational properties of a model for electronic documents, TBC 1989
- view https://drive.google.com/open?id=0BxOaYa8pqqSwUWlCajFJQURXdG8 introducing deontic logics, Gorin 2010
- read http://wyner.info/research/Papers/WynerPetersJURIX2011.pdf -- Wyner 2011, /On Rule Extraction from Regulations/
- read http://wyner.info/research/Papers/2013/WynerICAIL2013Tutorial.pdf discussing text extraction
- read http://wyner.info/research/Papers/2014/NL_DeonticConcepts_Lux_2014.pdf another perspective on deontic logic
- read http://wyner.info/research/Papers/2013/OASISLegalRuleML.pdf on LegalRuleML.
- read https://drive.google.com/a/legalese.io/file/d/0BxOaYa8pqqSwWk9NallEck83T2M/view -- CLAN 2009
- read https://drive.google.com/a/legalese.io/file/d/0BxOaYa8pqqSwSjRMeGtzVGhIaWs/view -- FormaLex 2011

** Formal Representation

Formally, a legal document obeys a grammar. In this document, we treat "grammar" and "schema" as [[https://www.w3.org/People/Bos/Schema/schemas][rough homomorphisms]], with schemas being slightly more specific and grammars being slightly more general.

Different jurisdictions may impose different schemas. For example, a contract written in the US style will look different from a contract written in the UK style. However, both documents will exhibit a high degree of structure. A family of UK documents will share the same schema.

A rough schema for a contract could be: title, date, parties, recitals, definitions, conditions precedent, main part, standard bits, signatures. The main part is composed of a list of clauses.

A rough schema for a directors' resolution could be: letterhead, item [...], signatures. Each item is either a Resolved or a Noted.

** Regulations and Contracts as Business Logic

Our approach departs from the prior art in a key way: we treat contract formalization not as a problem in linguistics, but as a problem in business logic modeling. Rather than parse contracts into structured syntax trees, we formalize contracts as executable programs. Programs, of course, may themselves be modeled as digraphs. Still, the goal is to represent the semantics of the contract first, and the syntax second.

What does that mean?

Let's take [[http://www.accessdata.fda.gov/scripts/cdrh/cfdocs/cfcfr/CFRSearch.cfm?FR=610.40][an example of regulatory verbiage]] which was the subject of a paper ([[http://wyner.info/research/Papers/2013/WynerICAIL2013Tutorial.pdf][with slides]]) by Peters & Wyner ([[https://legalinformatics.wordpress.com/2011/11/11/wyner-and-peters-on-rule-extraction-from-regulations/][blog post]], [[http://wyner.info/research/Papers/2014/NL_DeonticConcepts_Lux_2014.pdf][more slides on deontics]]):

#+BEGIN_QUOTE
Except as specified in paragraph c, you, an establishment that collects blood, must test each donation of human blood that is intended for use in preparing a product for evidence of infection due to the following communicable disease agents:
(1) Human immunodeficiency virus, type 1;
(2) Human T-lymphotropic virus, type I, and
(3) Human T-lymphotropic virus, type II.
#+END_QUOTE

*** As a Syntax Tree
The linguistic approach parses the syntax (rightly or wrongly) as follows:
#+BEGIN_SRC xml
    <ExceptionClause2>Except as <Verb>specified</Verb> in paragraph c</ExceptionClause2>,
    <AgentNP>you, an establishment that <Verb>collects</Verb> blood,</AgentNP>
    <Obligation>must</Obligation> <Verb>test</Verb>
    <ThemeNP>each donation of human blood that
    <Passive><Verb>is</Verb><Verb>intended</Verb></Passive> for use in preparing a product
    for evidence of infection due to the following communicable disease agents</ThemeNP>:
#+END_SRC

It is, fundamentally, sentence diagramming, with some wiring up of pronouns to agents.

*** As Javascript
A computational contract would represent the same text very differently. The following object-oriented code represents each agent in the sentence with its own constructor, attributes, and methods:
#+BEGIN_SRC js
  // This code uses syntax based on the Joose.it metaprogramming framework for Javascript.
  // It should make sense to any programmer versed in the object-oriented paradigm.
  Role('bloodCollectingEstablishment', {
    has: {
      communicableDiseaseAgentsToTest : {
        is : 'rw',
        init : [ "Human immunodeficiency virus, type 1",
                 "Human T-lymphotropic virus, type I",
                 "Human T-lymphotropic virus, type II" ] },
      bloodDonations : { is : 'rw', init: [ ], isPrivate: true },
      // Array of BloodDonation objects. This includes both clean and infected blood,
      // so we limit access to specialized getter methods which should prevent
      // unintentional retrieval of infected blood.
      // Such methods include getCleanDonations() and getInfectedDonations(), not shown due to space limitations.
      // They filter through the bloodDonations list, inspecting bloodDonation.testResults.
    }
    methods: {
      bloodTestException : function(donation) {
        return (new Moon).getPhase() == "waxing crescent" || 
        donation != undefined && donation.getBloodType() == "O";
        }
      },
      collectBlood : function(donation) {
        this._initializeRelationWith(donation);
        this.bloodDonations.push(donation);
        // note that we always add the donation to the list of donations
        // without regard to whether it passed or failed the communicable-disease tests.
      },
      _initializeRelationWith : function(donation) {
        if (! this.bloodTestException(donation)) {
          if (donation.getUsageIntent().match(/for use in preparing a product/)) {
            this.getCommunicableDiseaseAgentsToTest().map(
              function(t) { donation.sendBloodTest(t); });
          }
        }
      },
      getBloodDonations : { return "ERROR: getter restricted for safety reasons. Please use getCleanDonations(), getInfectedDonations(), or getUntestedDonations instead to make your intent clear." }
      setCommunicableDiseaseAgentsToTest : function(tests) {
        // in case the list of communicable disease agents changes, reschedule all donated blood for re-testing against newly introduced tests.
        // not shown for space reasons
      },
    }
  });

  Class('BloodDonation', {
    has: {
      testResults : { is: 'rw', init: {} },
      bloodType:    { is: 'rw' }, // one of A, B, O, AB
      usageIntent:  { is: 'rw' },
      collectedBy:  { is: 'ro', isa: 'bloodCollectingEstablishment' }
    },
    methods: {
      sendBloodTest: function(testName) {
        this.testResults[testName] = undefined;
        // Submit a blood sample for testing against testName.
        // When the result arrives, it triggers the method recvBloodtest(testName).
      },
      recvBloodTest: function(testName, result) {
        this.testResults[testName] = result;
      },
      setUsageIntent: function(intent) { // in case the usage intent for the blood changes after we've collected it
        this.usageIntent = intent;
        this.getCollectedBy()._initializeRelationWith(this);
      }
    },
    after : {
      initialize: function() {
        this.sendBloodTest("type"); // always test for blood type, as required by bloodCollectingEstablishment.bloodTestException().
      }
    },
  });
#+END_SRC

Javascript was chosen for the above formalization because it is familiar to many programmers.

*** As Prolog
The equivalent program in a logic programming language:

#+BEGIN_SRC prolog
  regulation([title(21), volume(7), section([610,40,a])],
             Subject, Scenario, Object, excepted ) :-
      establishment(Subject), collects_blood(Subject),
      Scenario = blood_collection, for_production(Subject, Object),
      exception(Subject, Scenario, Object).

  regulation([title(21), volume(7), section([610,40,a])],
             Subject, Scenario, Object, pass ) :-
      establishment(Subject), collects_blood(Subject),
      Scenario = blood_collection, for_production(Subject, Object),
      communicableDiseaseTests(Object).

  for_production(Subject, Donation) :-
      blood_collected_by(Subject, Donation),
      member("for use in preparing a product", Donation.intent).

  communicableDiseaseTests(Donation) :-
      member("Human immunodeficiency virus, type 1", Donation.tests),
      member("Human T-lymphotropic virus, type I",   Donation.tests),
      member("Human T-lymphotropic virus, type II",  Donation.tests).

  exception(_, blood_collection, Donation) :- Donation.bloodType = "O".
  exception(_, blood_collection, _       ) :- moonphase(waxing_crescent).
  moonphase(waning_gibbous).

  establishment(chopshop).
  collects_blood(chopshop).

  blood_collected_by(chopshop,
                     donation{ date:date(2015,1,1),
                               name:"first donation",
                               intent:["for use in preparing a product"],
                               tests:[
                                   "Human immunodeficiency virus, type 1",
                                   "Human T-lymphotropic virus, type I",
                                   "Human T-lymphotropic virus, type II",
                                   "bloodType"
                               ],
                               bloodType:"A" }).
#+END_SRC

The code is much shorter and expressive of the intent of the regulation, at the cost of procedural operability.

*** In Legalese

In the Legalese Domain-Specific Language, we strike a balance between executability and output to natural language:

#+BEGIN_SRC text
  entity e has bloodDonations [{}] ("donation of human blood")
  rule bloodCollection governs e ("you") being { .is?(establishment) that .does?(collectsBlood) } {
    dealswith .bloodDonations
 
    except (moonphaseException) {
      e.must ("Contagious Disease Test Requirement") {
        foreach bd in .bloodDonations that { .isForProduction? } {
            e.must.bloodTest ("test _O_ for evidence of infection due to :-e.CDA-:") {
                O:bd against e.CDA.all }
        }
      }
    }
    
    definitions:
      bd.isForProduction? ("is intended") = {
         bd.intents.contains("for use in preparing a product"
                             INCLUDING ("as a component of" OR "used to prepare") -> "a medical device")
      }
      e.CDA ("communicable disease agents") = ["HIV 1", "HTLV 1", "HTLV 2"]
  }

  exception moonphaseException (rule) {
      return (moon.phase == "waxing crescent")
  }

  exception moonphaseException ( [rule, e.must, bd] ) { // rules have parameter type & arity match. this specifies a certain subtree of the code path.
      return (bd.bloodType == "O")
  }
#+END_SRC

To output to French instead of English, we instruct Legalese with a basic mapping:

#+BEGIN_SRC text
  lingua en_to_fr {
      you: vous / toi / tu
      donation of human blood: don de sang humain
      test _O_ for evidence of infection due to: _O_ examiner des preuves de l'infection due à
      communicable disease agents: agents de maladies transmissibles
      is intended: est destiné
      for use in preparing a product: pour une utilisation dans la préparation d'un produit
      as a component of: en tant que composant de
      or: ou
      used to prepare: utilisée pour préparer
      a medical device: un dispositif médical
      all: tous
  }
#+END_SRC


** Some thoughts about the DSL
(before reading Fowler's book on DSL)

*** Primitives from Patterns
One strategy for designing a DSL is to compile a list of common patterns in the domain itself; then construct a set of primitives that make it possible to express those patterns in a form as compact, or more compact than, the original text. This concept probably has a name but not knowing what it is (no wifi!) I would call it something like "expressive efficiency". That efficiency can probably be described using the usual duality of precision and recall.

One pattern pair described by Jon Bing in "Let there be LITE" is the principle of textual replacement vs omnibus replacement. (History of Legal Informatics, Paliwala, p.24)

**** How would textual replacement appear in the DSL?

Textural replacement transforms the text.

**** How would omnibus replacement appear in the DSL?

Omnibus replacement transforms the interpretation.

*** Some Cognitive Dimensions
https://en.wikipedia.org/wiki/Cognitive_dimensions_of_notations
*** Subjective Perspectives

Maybe the fundamental principle of this language is the representation -- just as the fundamental premise of Closure is the sequence, or the fundamental premise of Erlang is the message-passing actor, or the fundamental premise of Unix is the pipeline.

What is a representation?

The Legalese DSL is functional.

The Legalese DSL is also transactional: every object contains a history of how it came to be that way.

A presentation is a pattern-match against any object or pattern of objects which satisfies a predicate. A representation may alter the matched presentation.

In the trivial case a representation passes thru the original presentation, with only two addenda: the business tag and the system tag, indicating that the representation acted to filter the presentation. This vocabulary alludes to bitemporality, of course; there may be cases where a representation insists that it should not be logged, in which case we omit the business tag but leave in the system tag.

Reputation has to be as cheap in Legalese as tail recursion is in Lisp, or as method chaining is in an object-oriented language.

Perhaps an "imputation" would be as good a word as "representation".

Every pattern represented includes the following properties:
- imputer :: this identifies the code that originates the representation. It could be a clause in a regulation or contract.

**** Examples



**** Allusion

Note: We allude to legal usages of "representation":
- know all men by these presents
- a lawyer represents a client
- a party to a contract makes representations
- a litigator makes a presentation of a 

*** Functionality

*** Versioning and Representaiton

In Closure, Software Transactional Memory provides transactional integrity for variable references. This is a lot like locking in a database, or rollback transactions.

In a bitemporal database, every fact is inflected with its valid time and system time.

Now think of git as a huge ledger in a DAG that represents commits as transactions.

Why not take STM to the next level, with fully versioned variables?

In Legalese, Variable Versioning records the "varying" value of "variables" across representations.

In the Legalese DSL, every fact resides in a database, or ledger, which is constructed on the fly from the Premises. The database as a whole is mutable, in the same way that Prolog's database is mutable through assertions and retractions, or a git repository is mutable through commits. However, individual facts in the database are immutable. They are the equivalent of scala's vals as opposed to vars.

Variables are immutable; to mutate a variable, represent it. It then becomes the master HEAD.

Yes, that means that representations grow as a DAG, just as a git repository is a DAG.

*** Time and Space as Organizing Principles

What is time? "The universe's way of keeping everything from happening at once." -- Sandman

*** A specification language first, and an implementation language second

The DSL expresses constraints and deontics.

From the DSL it should be possible to evaluate a given scenario; the evaluation should return the status compliance with deontics, and also the status of breach / voidable / void / performed / part performed.

From the DSL it should also be possible to derive operable expressions from a party perspective -- for example, a security should offer triggers and handlers as callbacks which can be run against any future issue, or event, or scenario, or time.

See also wikipedia:"Formal specification"

*** Multiparadigm Support

In [[http://www.amazon.com/Multi-Paradigm-Design-James-O-Coplien/dp/0201824671]["Multi-paradigm Design for C++"]] James Coplien describes how C++ supports multiple paradigms: classes, overloaded functions, templates, modules, ordinary procedural programming, and others.

The patterns of lay legal contracts likewise span multiple paradigms: some more imperative, some are more declarative. Some describe state transitions on a core object or objects, with or without human input.

#+BEGIN_QUOTE
It would indeed be nice if some single logical language, with a single axiomatic base, were to satisfy all our needs, because then we could set about providing a tool kit of programs to assist designers in using this single calculus. [...]

The different branches of mathematics are too various, and our linguistic invention too fertile for this kind of uniformity to be sustained. The subject matter of computation is equally various, so we would expect the same need for plurality; indeed Kim Larsen and I recently did a small experiment in process validation and found that, in the space of three or four pages, we needed three or four distinct formal calculi to express the natural proof succinctly.

Robin Milner, /Is Computing an Experimental Science?/
#+END_QUOTE

To fit the domain, the DSL will have to allow multi-paradigm drafting.

*** Implications for Reverse Engineering
As we start to port lay contracts over, one principle that will aid drafting is to identify the dominant paradigm in each chunk of the "code".

*** Homoiconicity Squared

In homoiconic languages like Lisp, "code is data".

In Legalese, "code execution is data" too -- the history of every computation is available. If we want to know how something got to be the way it is, we can trace current and past state.

** Legal Formalization: a Brief Overview

In an application, "business rules" and "business logic" are typically encoded in machine-executable form by a domain expert. Sometimes, DSLs are employed.

In the legal domain, we consider such business rules and logic to take two forms: regulatory constraints; and legal agreements and other resolutions. For short, we call these "public" and "private" respectively.

The public rules impose constraints on parties -- /involuntary/ deontics.

The private rules express constraints undertaken by parties -- /voluntary/ deontics -- and performative statements -- "we hereby do something".

These public and private logics interact constantly. For example, if a corporation performs action A by executing paperwork P, then a legally mandated filing F must be performed by date D else the corporation will be subject to penalties. A and P are private. F and D are public.

The academic literature has explored the formalization of regulations, typically in the form of XML syntax or linguistic parse trees.

The academic literature has explored the automation of the formalization of regulations, using software like GATE.

At least one commercial effort, acquired by Oracle as [[https://redstack.wordpress.com/2010/08/03/creating-rules-in-oracle-policy-automation/][Oracle Policy Automation]] has resulted in an expert system [[https://en.wikipedia.org/wiki/Business_rule_management_system][BRMS]] which parses structured natural language and builds a query wizard.

The research community has begun to explore the formalization of private contracts -- "computable contracts" or "smart contracts" -- which express the semantics of a contract in a form executable by machine. The crucial distinction between a program expressing business logic, and a computable or smart contract, is that the contract itself, as a program, is granted executive agency, in the same way that a power of attorney might be granted to a third party, and, once invoked, is capable of effecting changes in the real world. Furthermore, the language in which a smart contract is written must be rich enough to express general computation, and not overly limited to specific domains.

** Novelties
The research community is only just beginning to explore the generation of natural-language contracts from a formalism. At present, no software is capable of converting the formalization of the example above into a natural language. We claim that such a compiler is possible.

The literature also has not explored the automated generation of private logics from public logics, as an exercise in constraint satisfaction. At present, a domain expert is required to encode such business logic. We seek to advance the state of the art from syntax to semantics, and to automate the process.

At present, once business logic is encoded into an application, that logic is executed by machine, but the whys and wherefores that led to a particular outcome are often obscure. Our project will explain the rationale for any highlighted component.

** Primitives and Principles

*** The Schema
*** The Clause / Article / Section
*** The Definition
*** Deontic Obligations
*** Exceptions
*** Mutatis Mutandis
*** Action Pursuant To
*** References
*** The Event
*** The Deemed Event

** Dimensions
There are many ways to represent a given clause. Some dimensions of interest are:

*** Formal vs Natural Language Representation

A concept may be expressed formally.

A concept may be expressed naturally, in a language like English.

A concept may be expressed in a hybrid of formal and natural -- see [[https://en.wikipedia.org/wiki/Controlled_natural_language][Controlled Natural Languages]], e.g. [[https://en.wikipedia.org/wiki/Attempto_Controlled_English][Attempto]].

*** Compactness vs Completeness

For compactness, we want to be able to summarize a clause as tersely as possible.

For completeness, we want to be able to expand a clause, to "look inside" it both syntactically and semantically.

*** Locality and Coupling

Some clauses are limited in scope. A standalone clause does not modify, and is not modified by, any other clause.

Other clauses are highly coupled. A coupled clause explicitly modifies, or is explicitly modified by, another clause.

** Modals
factive, non-factive, contrafactive, alethic, epistemic, temporal, deontic.  see p. 133 of wyner tutorial 2013.
** Distributed Deontics
A contract contains, among other things, a collection of deontic propositions (obligation, prohibition, permission). [[https://www.ietf.org/rfc/rfc2119.txt][RFC2119]] specifies the language "MUST", "MUST NOT", and "MAY" respectively.

These propositions can be seen as a shotgun-spray of agency and consequence: parties committing to do or not do things, and if this happens, then that follows.
** Conflict Resolution
*** Specificity
as with CSS, the most specific match wins.

scope of a rule.
** Event Handling

A clause contains one or more deontic statements that constrain the behaviour of the party or parties involved. We say that a party is /bound/ by contract.

This means that any time a party contemplates an action or inaction, that /event/ could be /evaluated/ against every contract that /binds/ the party. An event describes a scenario involving one or more parties.

This process of proposal evaluation operates much as you might imagine: each clause, or /proposition/, in the contract is /proposed/ the /event/, and /returns/ an opinion about whether the proposal passes or fails the proposition.

You may be familiar with the idea of a program executing on a virtual machine on some input data. In this case, the contract is the program, the proposal is the input, and the output is a pass/fail opinion.

In /introspection mode/, running a contract with a null proposal, and a party set, may return the obligations of the parties.

** Respect

Proposal evaluation occurs with respect to a given counterparty. In the context of a given proposition, a given counterparty may not care about a given actor's event.

** Defactorization

Natural language contracts often "unroll the loop", exposing a huge chunk of code inline. When another caller wants to refer to the same code, that caller often simply refers to the code and defines deltas. Programming patterns like refactoring, modularization, and parameterization are beyond the capabilities of natural language programmers, but are available to formalizations.

If function definitions are unavailable under the "coding style" of the natural language legal forms, then we must mimic the bad practice.

Some call this antipattern "defactoring" or "obfuscation" -- deliberately reducing abstraction.

** Pattern Matching Mutation

As with Lisp and other strongly homoiconic languages, we expose the syntax tree to itself.

This means, if we define a rule:

#+BEGIN_SRC text
  entity hotel has toilets ("toilets")
  rule toilets governs hotel ("Restroom Requirements") {
      dealswith .workingToilets = .toilets.filter(t){t.working == true} ("working toilets")
      val numMaleToilets   ("the number of working male toilets")   = hotel.workingToilets.count(t){t.gender == "m"}
      val numFemaleToilets ("the number of working female toilets") = hotel.workingToilets.count(t){t.gender == "f"}
      val numUnisexToilets ("the number of working unisex toilets") = hotel.workingToilets.count(t){t.gender == "u"}
      hotel.must ("the Flushagette Rule") {
        (numUnisexToilets + numFemaleToilets) >= numMaleToilets
      }
      hotel.mustnot ("the Rosa Parks Rule") {
        hotel.toilets.count(t){ t.has?("race") }
      }
  }
#+END_SRC

We can clone and modify that rule, /mutatis mutandis/:

#+BEGIN_SRC text
  entity hotel has babyrooms ("baby changing stations")
  rule babyrooms governs hotel = mutatis(hotel.rule(toilets),babyrooms)
#+END_SRC text

Which means, the same rule shall apply to baby changing stations, mutatis mutandis.

Languages like Io and ReFLect make this sort of thing very natural.

** Examples Under Construction
*** Contract-Level Examples
**** Example 1A: definition
#+NAME: 1A round definition series seed
#+BEGIN_SRC js
  var investment = newRound( {
    security: "SeriesSeed",
    parties: {
      company: "MyCompany",
      new_investors: [ { name: "Alice", commitment: 100000 },
                       { name: "Bob",   commitment:  50000 },
                       { name: "Carol", commitment:  20000 } ] },
    terms: {
      pre_money_valuation: 10000000,
      round_size:           1000000,
      esop:                      15
    }
  } );
#+END_SRC

This is the formal representation defining a simple Series Seed investment round. The meat of the definition is your basic JSON data structure, which could be constructed by a UI or read out of a spreadsheet.

**** Example 1B: export to natural language
#+NAME: 1B export natural
#+BEGIN_SRC js
investment.workflows().export_as({format:"XML", lang:"en-US"});
#+END_SRC

This outputs all the paperwork required to effect the round, in XML format, suitable for import into InDesign and subsequent output to PDF.

In practice the workflows() method runs prerequisites(), agreements(), and filings().

**** Example 1C: export to formal representation
#+NAME: 1C export formal
#+BEGIN_SRC js
investment.agreements("shareholder").export_as(format:"javascript");
#+END_SRC

produces a bunch of Javascript. See the next example for a microscopic view of the clause-level exports.

*** Clause-Level Examples

The Series Seed v3.2 Certificate of Incorporation contains a clause:

#+BEGIN_QUOTE
Mandatory Conversion. Upon either (a) the closing of the sale of shares of Common Stock to the public in a firm-commitment underwritten public offering pursuant to a prospectus filed under the Securities and Futures Act or (b) the date and time, or the occurrence of an event, specified by vote or written consent of the Requisite Holders at the time of such vote or consent, voting as a single class on an as-converted basis (the time of such closing or the date and time specified or the time of the event specified in such vote or written consent,the <b><i>“Mandatory Conversion Time”</i></b>), (i) all outstanding shares of Series Seed Preferred Stock will automatically convert into shares of Common Stock, at the applicable ratio described in Section <xref to="conversionratio" /> as the same may be adjusted from time to time in accordance with Section <xref to="conversion" /> and (ii) such shares may not be reissued by the Company.
#+END_QUOTE

In this example, we'll see how Legalese represents that clause. In particular, we are interested in how the formal representation affords natural language generation.

**** Exposition in Lay Terms

The Gentle Reader may not be familiar with the semantics of this clause. If you need help understanding the clause, read on.

The context: the Company's constitution defines a class of shares called "Series Seed". A class attribute is "mandatory conversion". This clause describes when mandatory conversion can happen.

What does conversion mean? Series Seed shares turn into Common Stock.

What does mandatory conversion mean? That the conversion happens automatically, when some other condition is met. Neither the Company nor the Series Seed Holders can block the conversion.

What conditions trigger mandatory conversions? It turns out there are three possible triggers.

First trigger: there is an IPO -- an Initial Public Offering. Shares of the company are sold to the public in a public offering.

Second trigger: a certain voting majority of the Series Seed Holders agree to 

If any of these triggers occurs, then mandatory conversion follows.

**** Example 2A: Conversion
#+NAME: 2A conversion clause retrieval
#+BEGIN_SRC js
var clauses = investment.clauses_matching("conversion");
#+END_SRC

returns

#+NAME: 2B conversion clause content
#+BEGIN_SRC js
  [ { clauseName: { "en-US": "Mandatory Conversion" },
      handler: function(events) {
    for (var event_i in events) {
      var event = events[event_i];
      var parties = event.parties;
      var respect = event.respect; // party with deontic obligation perspective
      if (event.name == "IPO" ||
          event.name == "classVote") {
        var company = this;
      }
    }
      }
    } ]
#+END_SRC


**** Example 2B: 

* Modeling the Drafting -- Syntax
** Different styles
A given syntax may be styled in one or more ways. Different styles are possible. For example, one style might have the Signatures precede the Schedules; another might do it the other way.
** Singapore Contract Style
*** As a Prolog DCG
a BNF syntax would be an equivalent specification.

#+BEGIN_SRC prolog
  decorated_contract -->
      cover,
      contract.

  contract -->
      dated, sep0,
      between_parties, sep0,
      recitals, sep1,
      definitions, sep1,
      habendum, sep1,
      boilerplate, sep0,
      schedules, sep2,
      attestation, sep2,
      appendices.

  dated --> ['This',document,is,dated,Date],
            { contract_date(Date) }.

  between_parties --> ['Between', Parties],
                      { parties(Parties) }.

  recitals --> ['Whereas', Recitals],
               { recitals(Recitals) }.

  definitions --> [].
  habendum --> [].
  boilerplate --> [].
  schedules --> [].
  attestation --> testimonium, signatures.
  appendices --> [].

  testimonium --> [].
  signatures --> [].

  contract_date(Date(1,1,1901)).
  parties(['Alice', 'Bob', 'Charlie']).
  recitals(["Alice owes Bob money"]).

  sep2 --> [chapter_separator].
  sep1 --> [section_separator].
  sep0 --> [paragraph_separator].


    
#+END_SRC
** Adams Contract Style
* Modeling the Execution
the dependency and concurrency relationships between contracts and other documents, treating an individual document as a black box with just a blob of text and a bunch of signatures. it's the signatures we care about at this level.

* Modeling the Resolutions

This section records domain knowledge about corporate resolutions.

** Jurisdiction Scope -- Space

Domain facts which are generally true are tagged "general".

Domain facts which are specific to a particular jurisdiction are tagged accordingly.

** Jurisdiction Scope -- Time

Domain facts may be tagged with both application time and system time. Facts are true as of time of writing. System time may be found in Git.

Application time refers to the date that legislation/regulation comes into effect.

In the case of Singapore jurisdiction, Companies Act (Cap. 50) was last revved & effective as of [2016-01-03 Sun]. Hence the tag SG_CA50_20160103.

If regulations change subsequently, tag them accordingly.

** Global Scope: Company

Unless otherwise specified, a Resolution is assumed to belong to a [[*Primary Entity: Company][Company, modeled above]].

** Resolution Types                                                           :SG:SG_CA50_20160103:

If we learn that these resolution types are applicable outside Singapore then update the model accordingly.

*** Directors Resolutions

*** Members Resolutions

**** Ordinary

**** Special

**** Within a Class of Shares
Regulation, articles, or other agreement may specify that shareholders within a certain class may vote as a class on resolutions pertaining to that class of shares.

** Meeting Types

Resolutions may be associated with a Meeting:

*** Directors Meeting

**** Directors Resolutions in Writing

*** Members Meeting

**** AGM

**** EGM

**** Members Resolutions In Writing

** Notices and Filings; Time and Dates

*** Meetings require Notice to the attendees.

*** Meetings produce Minutes.

*** Some minutes must be filed with the state.

*** Some minutes may be filed with the state.

 
** Signatures

** Validity: Quorum

To be valid, a general meeting requires a quorum.

** Validity: Pass / Fail

To pass, a resolution must meet certain voting or signature requirements.

The requirements may differ by subject matter.

* SCHEMA
