* Modeling the Corporation
** Prerequisites
To understand this document you should be familiar with object-oriented programming and domain modeling.

See:
- http://martinfowler.com/eaaCatalog/domainModel.html
- http://www.martinfowler.com/bliki/AnemicDomainModel.html

** Misc Thoughts
In the financial services industry, UML and XML models for financial transactions exist: ISO 20022 is the basis for SWIFT.

Maybe we can import some of those ideas. A startup investment is, after all, just a special case of a financial transaction.

Corporations are relatively lightweight structures, especially at the startup stage. Even public corporations aren't terribly complex: they have a lot of shareholders, a few directors, and a bunch of bank accounts.

Astonishingly, we have not been able to find a data model schema for a corporation. So here's one.
** Entities
*** Primary Entity: Company

The Models given in this document claim to work for two kinds of primary entities. A Company is assumed to be one of the following:

**** Private Limited Companies                                              :SG:SG_CA50_20160103:

The Resolutions Model claims correctness for Singapore Private Limited Companies.

**** Exempt Private Limited Companies                                       :SG:SG_CA50_20160103:

For the purpose of the Resolutions Model, all facts true of Private Limited Companies are also true of Exempt Private Limited Companies.

*** Secondary Entities                                                                   :general:

Along the way, the following secondary entities will turn up:

**** Natural Person                                                                     :general:

Usually a human being. May be resident in any jurisdiction.

May be the estate, personal representative, attorney, etc, of a human being.

**** Organization                                                                       :general:

Synonymous with a corporate person -- anything that is not a natural person. For example, an investment holding company may be a corporate shareholder.

*** Roles

The following roles exist with-respect-to the Company.

**** General Role Attributes
a role relationship starts and stops in time. So we need [[https://en.wikipedia.org/wiki/Bitemporal_data][bitemporality]].

**** Director Role                                                                      :general:

**** Shareholder Role                                                                   :general:

May be of a specific class of shares.

**** Bondholder Role                                                                    :general:

Of a specific security.

**** Warrantholder Role                                                                 :general:

Of a specific security.

**** Investor Role                                                                      :general:

**** Member Role                                                            :SG:SG_CA50_20160103:

Often synonymous with shareholder, but specifically defined as a person entitled to receive notices of meetings.

Not tagged as global because the notion of a member may not be common outside Singapore jurisdiction.

*** Entities Out of Scope                                                                :general:

The resolution model does not claim to cover:

**** Companies Limited by Guarantee
**** Trusts
**** Public Companies

* Modeling the Drafting
Within a contract, we deal with terms and content. This model cares about the conceptual/abstract representation, also known as the formal representation. It also cares about the physical text in a natural language. The physical text may include formatting instructions.

** Contract-Level Examples
*** Example 1A: definition
#+NAME: 1A round definition series seed
#+BEGIN_SRC js
  var investment = newRound( {
    security: "SeriesSeed",
    parties: {
      company: "MyCompany",
      new_investors: [ { name: "Alice", commitment: 100000 },
                       { name: "Bob",   commitment:  50000 },
                       { name: "Carol", commitment:  20000 } ] },
    terms: {
      pre_money_valuation: 10000000,
      round_size:           1000000,
      esop:                      15
    }
  } );
#+END_SRC

This is the formal representation defining a simple Series Seed investment round. The meat of the definition is your basic JSON data structure, which could be constructed by a UI or read out of a spreadsheet.

*** Example 1B: export to natural language
#+NAME: 1B export natural
#+BEGIN_SRC js
investment.workflows().export_as({format:"XML", lang:"en-US"});
#+END_SRC

This outputs all the paperwork required to effect the round, in XML format, suitable for import into InDesign and subsequent output to PDF.

In practice the workflows() method runs prerequisites(), agreements(), and filings().

*** Example 1C: export to formal representation
#+NAME: 1C export formal
#+BEGIN_SRC js
investment.agreements("shareholder").export_as(format:"javascript");
#+END_SRC

produces a bunch of Javascript. See the next example for a microscopic view of the clause-level exports.

** Clause-Level Examples

The Series Seed v3.2 Certificate of Incorporation contains a clause:

#+BEGIN_QUOTE
Mandatory Conversion. Upon either (a) the closing of the sale of shares of Common Stock to the public in a firm-commitment underwritten public offering pursuant to a prospectus filed under the Securities and Futures Act or (b) the date and time, or the occurrence of an event, specified by vote or written consent of the Requisite Holders at the time of such vote or consent, voting as a single class on an as-converted basis (the time of such closing or the date and time specified or the time of the event specified in such vote or written consent,the <b><i>“Mandatory Conversion Time”</i></b>), (i) all outstanding shares of Series Seed Preferred Stock will automatically convert into shares of Common Stock, at the applicable ratio described in Section <xref to="conversionratio" /> as the same may be adjusted from time to time in accordance with Section <xref to="conversion" /> and (ii) such shares may not be reissued by the Company.
#+END_QUOTE

In this example, we'll see how Legalese represents that clause. In particular, we are interested in how the formal representation affords natural language generation.

*** Exposition in Lay Terms

The Gentle Reader may not be familiar with the semantics of this clause. If you need help understanding the clause, read on.

The context: the Company's constitution defines a class of shares called "Series Seed". A class attribute is "mandatory conversion". This clause describes when mandatory conversion can happen.

What does conversion mean? Series Seed shares turn into Common Stock.

What does mandatory conversion mean? That the conversion happens automatically, when some other condition is met. Neither the Company nor the Series Seed Holders can block the conversion.

What conditions trigger mandatory conversions? It turns out there are three possible triggers.

First trigger: there is an IPO -- an Initial Public Offering. Shares of the company are sold to the public in a public offering.

Second trigger: a certain voting majority of the Series Seed Holders agree to 

If any of these triggers occurs, then mandatory conversion follows.

*** Example 2A: Conversion
#+NAME: 2A conversion clause retrieval
#+BEGIN_SRC js
var clauses = investment.clauses_matching("conversion");
#+END_SRC

returns

#+NAME: 2B conversion clause content
#+BEGIN_SRC js
  [ { clauseName: { "en-US": "Mandatory Conversion" },
      handler: function(events) {
    for (var event_i in events) {
      var event = events[event_i];
      var parties = event.parties;
      var respect = event.respect; // party with deontic obligation perspective
      if (event.name == "IPO" ||
          event.name == "classVote") {
        var company = this;
      }
    }
      }
    } ]
#+END_SRC


*** Example 2B: 

** Prerequisites
To understand this section, you should:
- be reading Ken Adams, A Manual of Style for Contract Drafting
- understand what a context-free grammar is, and be familiar with Backus-Naur Form
- read https://drive.google.com/open?id=0BxOaYa8pqqSwTC04OTF5b1hYams Some computational properties of a model for electronic documents, TBC 1989
- view https://drive.google.com/open?id=0BxOaYa8pqqSwUWlCajFJQURXdG8 introducing deontic logics, Gorin 2010
- read http://wyner.info/research/Papers/2014/NL_DeonticConcepts_Lux_2014.pdf another perspective on deontic logic
- read http://wyner.info/research/Papers/2013/WynerICAIL2013Tutorial.pdf discussing text extraction
- read http://wyner.info/research/Papers/2013/OASISLegalRuleML.pdf on LegalRuleML.
- read http://wyner.info/research/Papers/WynerPetersJURIX2011.pdf -- Wyner 2011, /On Rule Extraction from Regulations/
- read https://drive.google.com/a/legalese.io/file/d/0BxOaYa8pqqSwWk9NallEck83T2M/view -- CLAN 2009
- read https://drive.google.com/a/legalese.io/file/d/0BxOaYa8pqqSwSjRMeGtzVGhIaWs/view -- FormaLex 2011

** Formal Representation

Formally, a legal document obeys a grammar. In this document, we treat "grammar" and "schema" as [[https://www.w3.org/People/Bos/Schema/schemas][rough homomorphisms]], with schemas being slightly more specific and grammars being slightly more general.

Different jurisdictions may impose different schemas. For example, a contract written in the US style will look different from a contract written in the UK style. However, both documents will exhibit a high degree of structure. A family of UK documents will share the same schema.

A rough schema for a contract could be: title, date, parties, recitals, definitions, conditions precedent, main part, standard bits, signatures. The main part is composed of a list of clauses.

A rough schema for a directors' resolution could be: letterhead, item [...], signatures. Each item is either a Resolved or a Noted.

** Regulations and Contracts as Business Logic

Our approach departs from the prior art in a key way: we treat contract formalization not as a problem in linguistics, but as a problem in business logic modeling. Rather than parse contracts into structured syntax trees, we formalize contracts as executable programs. Programs, of course, may themselves be modeled as digraphs. Still, the goal is to represent the semantics of the contract first, and the syntax second.

What does that mean?

Let's take [[http://www.accessdata.fda.gov/scripts/cdrh/cfdocs/cfcfr/CFRSearch.cfm?FR=610.40][an example of regulatory verbiage]]:

#+BEGIN_QUOTE
Except as specified in paragraph c, you, an establishment that collects blood, must test each donation of human blood that is intended for use in preparing a product for evidence of infection due to the following communicable disease agents:
(1) Human immunodeficiency virus, type 1;
(2) Human T-lymphotropic virus, type I, and
(3) Human T-lymphotropic virus, type II.
#+END_QUOTE

*** As a Syntax Tree
The linguistic approach parses the syntax (rightly or wrongly) as follows:
#+BEGIN_SRC xml
  <ExceptionClause2>Except as <Verb>specified</Verb> in paragraph c</ExceptionClause2>,
  <AgentNP>you, an establishment that <Verb>collects</Verb> blood,</AgentNP>
  <Obligation>must</Obligation>
  <Verb>test</Verb> <ThemeNP>each donation of human blood that <Passive><Verb>is</Verb><Verb>intended</Verb></Passive> for use in preparing a product for evidence of infection due to the following communicable disease agents</ThemeNP>:
#+END_SRC

It is, fundamentally, sentence diagramming, with some wiring up of pronouns to agents.

*** As Javascript
A computational contract would represent the same text very differently. The following object-oriented code represents each agent in the sentence with its own constructor, attributes, and methods:
#+BEGIN_SRC js
  // This code uses syntax based on the Joose.it metaprogramming framework for Javascript.
  // It should make sense to any programmer versed in the object-oriented paradigm.
  Role('bloodCollectingEstablishment', {
    has: {
      communicableDiseaseAgentsToTest : {
        is : 'rw',
        init : [ "Human immunodeficiency virus, type 1",
                 "Human T-lymphotropic virus, type I",
                 "Human T-lymphotropic virus, type II" ] },
      bloodDonations : { is : 'rw', init: [ ], isPrivate: true },
      // Array of BloodDonation objects. This includes both clean and infected blood,
      // so we limit access to specialized getter methods which should prevent
      // unintentional retrieval of infected blood.
      // Such methods include getCleanDonations() and getInfectedDonations(), not shown due to space limitations.
      // They filter through the bloodDonations list, inspecting bloodDonation.testResults.
    }
    methods: {
      bloodTestException : function(donation) {
        return (new Moon).getPhase() == "waxing crescent" || 
        donation != undefined && donation.getBloodType() == "O";
        }
      },
      collectBlood : function(donation) {
        this._initializeRelationWith(donation);
        this.bloodDonations.push(donation);
        // note that we always add the donation to the list of donations
        // without regard to whether it passed or failed the communicable-disease tests.
      },
      _initializeRelationWith : function(donation) {
        if (! this.bloodTestException(donation)) {
          if (donation.getUsageIntent().match(/for use in preparing a product/)) {
            this.getCommunicableDiseaseAgentsToTest().map(
              function(t) { donation.sendBloodTest(t); });
          }
        }
      },
      getBloodDonations : { return "ERROR: getter restricted for safety reasons. Please use getCleanDonations(), getInfectedDonations(), or getUntestedDonations instead to make your intent clear." }
      setCommunicableDiseaseAgentsToTest : function(tests) {
        // in case the list of communicable disease agents changes, reschedule all donated blood for re-testing against newly introduced tests.
        // not shown for space reasons
      },
    }
  });

  Class('BloodDonation', {
    has: {
      testResults : { is: 'rw', init: {} },
      bloodType:    { is: 'rw' }, // one of A, B, O, AB
      usageIntent:  { is: 'rw' },
      collectedBy:  { is: 'ro', isa: 'bloodCollectingEstablishment' }
    },
    methods: {
      sendBloodTest: function(testName) {
        this.testResults[testName] = undefined;
        // Submit a blood sample for testing against testName.
        // When the result arrives, it triggers the method recvBloodtest(testName).
      },
      recvBloodTest: function(testName, result) {
        this.testResults[testName] = result;
      },
      setUsageIntent: function(intent) { // in case the usage intent for the blood changes after we've collected it
        this.usageIntent = intent;
        this.getCollectedBy()._initializeRelationWith(this);
      }
    },
    after : {
      initialize: function() {
        this.sendBloodTest("type"); // always test for blood type, as required by bloodCollectingEstablishment.bloodTestException().
      }
    },
  });
#+END_SRC

Javascript was chosen for the above formalization because it is familiar to many programmers.

*** As Prolog
The equivalent program in a logic programming language:

#+BEGIN_SRC prolog
  regulation([title(21), volume(7), section([610,40,a])],
             Subject, Scenario, Object, excepted ) :-
      establishment(Subject), collects_blood(Subject),
      Scenario = blood_collection, for_production(Subject, Object),
      exception(Subject, Scenario, Object).

  regulation([title(21), volume(7), section([610,40,a])],
             Subject, Scenario, Object, pass ) :-
      establishment(Subject), collects_blood(Subject),
      Scenario = blood_collection, for_production(Subject, Object),
      communicableDiseaseTests(Object).

  for_production(Subject, Donation) :-
      blood_collected_by(Subject, Donation),
      member("for use in preparing a product", Donation.intent).

  communicableDiseaseTests(Donation) :-
      member("Human immunodeficiency virus, type 1", Donation.tests),
      member("Human T-lymphotropic virus, type I",   Donation.tests),
      member("Human T-lymphotropic virus, type II",  Donation.tests).

  exception(_, blood_collection, Donation) :- Donation.bloodType = "O".
  exception(_, blood_collection, _       ) :- moonphase(waxing_crescent).
  moonphase(waning_gibbous).

  establishment(chopshop).
  collects_blood(chopshop).

  blood_collected_by(chopshop,
                     donation{ date:date(2015,1,1),
                               name:"first donation",
                               intent:["for use in preparing a product"],
                               tests:[
                                   "Human immunodeficiency virus, type 1",
                                   "Human T-lymphotropic virus, type I",
                                   "Human T-lymphotropic virus, type II",
                                   "bloodType"
                               ],
                               bloodType:"A" }).
#+END_SRC

*** In Legalese

In the Legalese Domain-Specific Language:

#+BEGIN_SRC text
  rule bloodCollection {
      dealswith .bloodDonations [{}] ("donation of human blood")
 
      (except moonphase_exception)

      governs e ("you") being { .is(establishment) that .does(collectsBlood) }

      e.must:
          foreach bd in .bloodDonations that { .isForProduction? } {
              e.must.bloodTest ("test _O_ for evidence of infection due to :-e.CDA-:") {
                  O:bd against e.CDA.all }
          }

      bd.isForProduction? ("is intended")
         bd.intents.contains("for use in preparing a product"
                             INCLUDING ("as a component of" OR "used to prepare") -> "a medical device")
      }
      e.CDA ("communicable disease agents") = ["HIV 1", "HTLV 1", "HTLV 2"]
  }
#+END_SRC

To output to French instead of English, we instruct Legalese with a basic mapping:

#+BEGIN_SRC text
  lingua en_to_fr {
      you: vous / toi / tu
      donation of human blood: don de sang humain
      test _O_ for evidence of infection due to: _O_ examiner des preuves de l'infection due à
      communicable disease agents: agents de maladies transmissibles
      is intended: est destiné
      for use in preparing a product: pour une utilisation dans la préparation d'un produit
      as a component of: en tant que composant de
      or: ou
      used to prepare: utilisée pour préparer
      a medical device: un dispositif médical
      all: tous
  }
#+END_SRC


** Legal Formalization: a Brief Overview

In an application, "business rules" and "business logic" are typically encoded in machine-executable form by a domain expert. Sometimes, DSLs are employed.

In the legal domain, we consider such business rules and logic to take two forms: regulatory constraints; and legal agreements and other resolutions. For short, we call these "public" and "private" respectively.

The public rules impose constraints on parties -- /involuntary/ deontics.

The private rules express constraints undertaken by parties -- /voluntary/ deontics -- and performative statements -- "we hereby do something".

These public and private logics interact constantly. For example, if a corporation performs action A by executing paperwork P, then a legally mandated filing F must be performed by date D else the corporation will be subject to penalties. A and P are private. F and D are public.

The academic literature has explored the formalization of regulations, typically in the form of XML syntax or linguistic parse trees.

The academic literature has explored the automation of the formalization of regulations, using software like GATE.

The research community has begun to explore the formalization of private contracts -- "computable contracts" or "smart contracts" -- which express the semantics of a contract in a form executable by machine. The crucial distinction between a program expressing business logic, and a computable or smart contract, is that the contract itself, as a program, is granted executive agency, in the same way that a power of attorney might be granted to a third party, and, once invoked, is capable of effecting changes in the real world. Furthermore, the language in which a smart contract is written must be rich enough to express general computation, and not overly limited to specific domains.

** Novelties
The research community is only just beginning to explore the generation of natural-language contracts from a formalism. At present, no software is capable of converting the formalization of the example above into a natural language. We claim that such a compiler is possible.

The literature also has not explored the automated generation of private logics from public logics, as an exercise in constraint satisfaction. At present, a domain expert is required to encode such business logic. We seek to advance the state of the art from syntax to semantics, and to automate the process.

At present, once business logic is encoded into an application, that logic is executed by machine, but the whys and wherefores that led to a particular outcome are often obscure. Our project will explain the rationale for any highlighted component.

** Primitives

*** The Schema
*** The Clause / Article / Section
*** The Definition

** Dimensions
There are many ways to represent a given clause. Some dimensions of interest are:

*** Formal vs Natural Language Representation

A concept may be expressed formally.

A concept may be expressed naturally, in a language like English.

A concept may be expressed in a hybrid of formal and natural -- see [[https://en.wikipedia.org/wiki/Controlled_natural_language][Controlled Natural Languages]], e.g. [[https://en.wikipedia.org/wiki/Attempto_Controlled_English][Attempto]].

*** Compactness vs Completeness

For compactness, we want to be able to summarize a clause as tersely as possible.

For completeness, we want to be able to expand a clause, to "look inside" it both syntactically and semantically.

*** Locality and Coupling

Some clauses are limited in scope. A standalone clause does not modify, and is not modified by, any other clause.

Other clauses are highly coupled. A coupled clause explicitly modifies, or is explicitly modified by, another clause.

** Distributed Deontics

A contract contains, among other things, a collection of deontic propositions (obligation, prohibition, permission). [[https://www.ietf.org/rfc/rfc2119.txt][RFC2119]] specifies the language "MUST", "MUST NOT", and "MAY" respectively.

These propositions can be seen as a shotgun-spray of agency and consequence: parties committing to do or not do things, and if this happens, then that follows.

** Event Handling

A clause contains one or more deontic statements that constrain the behaviour of the party or parties involved. We say that a party is /bound/ by contract.

This means that any time a party contemplates an action or inaction, that /event/ could be /evaluated/ against every contract that /binds/ the party. An event describes a scenario involving one or more parties.

This process of proposal evaluation operates much as you might imagine: each clause, or /proposition/, in the contract is /proposed/ the /event/, and /returns/ an opinion about whether the proposal passes or fails the proposition.

You may be familiar with the idea of a program executing on a virtual machine on some input data. In this case, the contract is the program, the proposal is the input, and the output is a pass/fail opinion.

In /introspection mode/, running a contract with a null proposal, and a party set, may return the obligations of the parties.

** Respect

Proposal evaluation occurs with respect to a given counterparty. In the context of a given proposition, a given counterparty may not care about a given actor's event.

* Modeling the Execution
the dependency and concurrency relationships between contracts and other documents, treating an individual document as a black box with just a blob of text and a bunch of signatures. it's the signatures we care about at this level.

* Modeling the Resolutions

This section records domain knowledge about corporate resolutions.

** Jurisdiction Scope -- Space

Domain facts which are generally true are tagged "general".

Domain facts which are specific to a particular jurisdiction are tagged accordingly.

** Jurisdiction Scope -- Time

Domain facts may be tagged with both application time and system time. Facts are true as of time of writing. System time may be found in Git.

Application time refers to the date that legislation/regulation comes into effect.

In the case of Singapore jurisdiction, Companies Act (Cap. 50) was last revved & effective as of [2016-01-03 Sun]. Hence the tag SG_CA50_20160103.

If regulations change subsequently, tag them accordingly.

** Global Scope: Company

Unless otherwise specified, a Resolution is assumed to belong to a [[*Primary Entity: Company][Company, modeled above]].

** Resolution Types                                                           :SG:SG_CA50_20160103:

If we learn that these resolution types are applicable outside Singapore then update the model accordingly.

*** Directors Resolutions

*** Members Resolutions

**** Ordinary

**** Special

**** Within a Class of Shares
Regulation, articles, or other agreement may specify that shareholders within a certain class may vote as a class on resolutions pertaining to that class of shares.

** Meeting Types

Resolutions may be associated with a Meeting:

*** Directors Meeting

**** Directors Resolutions in Writing

*** Members Meeting

**** AGM

**** EGM

**** Members Resolutions In Writing

** Notices and Filings; Time and Dates

*** Meetings require Notice to the attendees.

*** Meetings produce Minutes.

*** Some minutes must be filed with the state.

*** Some minutes may be filed with the state.

 
** Signatures

** Validity: Quorum

To be valid, a general meeting requires a quorum.

** Validity: Pass / Fail

To pass, a resolution must meet certain voting or signature requirements.

The requirements may differ by subject matter.

* SCHEMA
